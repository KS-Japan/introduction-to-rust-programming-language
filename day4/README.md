# day
### 所有権
メモリはガベージコレクションやメモリの確保開放で管理をするのが一般的だが、Rustは第3の手法をとっている。<br>
コンパイラがコンパイル時にチェックする一定の規則とともに所有権システムを通じて管理されている。<br>
どの所有権機能も動作を遅くなる原因になることはない。<br>

### スタック
last in, first out（LIFO)：最初に入れたものを最後に出す。<br>
データを追加することをpush, データを取り除くことをpopという。<br>
スタックは高速。<br>
スタック上のデータは全て既知の固定サイズでなければならない。<br>

### ヒープ
ヒープにデータを置く際に、空の領域を見つけ、領域を使用中にし、ポインタを返す。<br>
ポインタとは、その場所へのアドレスを示す。<br>
この過程は、ヒープに領域を確保する(allocating on the heap)と呼ばれ、時としてそのフレーズを単にallocateするなどと省略したりする。<br>
スタックのデータへのアクセスよりも低速。<br>
ヒープに大きな領域を確保する行為も時間がかかることがある。<br>

### スコープ
スコープ("{}")内でのみ宣言した変数は有効になる。<br>
このスコープ抜けるまで有効なままである。<br>
スコープ外にでるとdrop関数が呼ばれ、解放される。<br>

### ムーブ
以下で宣言したStringは、ptr(文字列の中身を保持するメモリへのポインタ),len(長さ),capacity(許容量 byte)の3つの部品でできている。<br>
ポインタ情報は、indexとvalueでできている。<br>
```
let s1 = String::from("Hello");
let s2 = s1;
```
a1とs2の両方が同じデータポインタを指していることは問題になるため以下を実行するとエラーになる。<br>
```
println!("{}, rust!", s1);
```
rustはスコープから外れると自動でdrop関数を呼び出し、メモリ開放を行う。<br>
同じポインタ情報を保有している変数がスコープから外れてしまうと、二重解放が発生してしまう。<br>
二重開放とは、memory corruption(メモリ崩壊)の原因になり、セキュリティ上の脆弱性を生むことになる<br>
そのため、rustはメモリをコピーする代わりに、コンパイラはs1は有効ではないと考えs1の参照を無効にする<br>
ポインタと長さ、許容量をコピーする考えは、ほかの言語の"shallow copy"に似ているが、<br>
rustは変数ごと無効にするため、区別するためにムーブと名付けている。<br>

### クローン
異なる変数が同じポインタ情報を保有しているため、コピー後はコピー元の変数を利用できなくなる。<br>
クローンを利用することで、意図的にコピー元の変数も維持することができる<br>
同じヒープデータを別のメモリに格納することで、二つの変数とも利用することができる仕組みになっている<br>

### コピー
ヒープの場合はコピーされるとムーブが実行され、コピー元が利用停止できなくなるが、<br>
整数のような既知のサイズを持つ型はスタックに格納されるため、例外扱いされるためムーブが実行されないため、<br>
変数xもyも利用することができる。<br>
```
let x = 5;
let y = x;
```
